---
layout: post
title: "The Game of Go: a Programmer's Perspective"
date: 2012-04-13 08:30
author: Louis Chatriot
comments: true
categories: game, go, programming, algorithm, monte carlo tree-search
---


The game of go is very interesting from an AI programmer's point of
view, because of how difficult it is to make a computer compete against
a stromg human and the ideas researchers used to get closer to that goal.  


[![Go](http://farm1.staticflickr.com/134/322662164_0260e91add_n.jpg)](http://www.flickr.com/photos/92544159@N00/322662164/)
*by [oblivionz](http://www.flickr.com/photos/obli/ "Author")*  


## Game of Go: a (very) brief overview
Go is wildly popular in Asia but little known in the Western world. Similar to Chess, it is a strategic game where two players take
turn placing stones on a board. The two key differences between these
two are:  

* In Go, the board starts empty, and you add stones at each turn vs
  chess where you start with an army and try to destroy the other one
* The [rules](http://senseis.xmp.net/?RulesOfGoIntroductory) are much simpler in Go then in Chess: in particular there is only one type of stone vs the different Chess pieces

I really encourage you to check it out, you can [learn to play here](http://senseis.xmp.net/?RulesOfGoIntroductory) and [play here](http://www.gokgs.com/).


## Compexity, comparison to chess
Even though the rules are so simple, it has proven to be very hard to
build a good Go-playing program. In fact, while top Chess-playing
softwares can compete with the best humans (remember how Deep Blue beat
Gary Kasparov in 1997), even children can beat the best Go-playing
programs. There are three main reasons for this:  

* **Game-tree complexity**: there are about [10<sup>123</sup> possible games
  in Chess](http://en.wikipedia.org/wiki/Shannon_number). For Go,
[estimates vary](http://en.wikipedia.org/wiki/Go_and_mathematics) but
the [American Go Association reckons there are 10<sup>700</sup> possible
games](http://www.usgo.org/resources/topten.html). This is because there
are more turns in a Go game than in a Chess game (200 vs 50 on average),
and there are more possibilities at each turn in Go (up to 350 vs 50).
* **[Lack of a good heuristic](http://en.wikipedia.org/wiki/Evaluation_function)**: Chess programs are able to evaluate quite accurately and quickly whether a given position is better than another one. On the contrary, no good heuristic has been found for Go yet.
* **Pattern-recognition**: strong Go players rely heavily on recognizing
  the shapes the stones take. There are too many of them for a computer
to try and recognize in a game timeframe.


## Key ideas behind current Go-playing programs
This complexity is what makes the study of Go algorithms so interesting.
A few years ago we saw a spectacular improvement of computers, led by a
program called [MoGo](http://www.lri.fr/~teytaud/mogo.html). The key
ideas behind MoGo are:  

* **Position evaluation using random games**: paradoxically, it was
  found that the best way to evaluate a position is to, from this
position, play a lot of games were each player put stones at random
on the board. This position's score is simply the percentage of won
random games.
* **Use of [multi-armed bandit](http://en.wikipedia.org/wiki/Multi-armed_bandit) algorithms** to decrease the branching factor (the number of moves the program has to consider at each turn). The goal here is to optimize the trade-off between exploration (trying new moves) and exploitation (further testing of most promising moves to select the best one). The computer begins with a prior probability distribution for every possible move. It picks one according to this distribution, plays a random game from the corresponding position and uses the result to update the probability for this move. It then selects another possible move according to the updated distribution and so on.
* **Use of a little expert knowledge**: a little expert knowledge has
  been added to Mogo. For example, the prior distribution used in the
multi-armed bandit is calculated so as to avoid trivially stupid moves.
For the opening of the game, classic starting positions are also
favored. And the random games are not so random since hey avoid a
certain moves according to simple patterns. Nonetheless, expert
knowledge is used scarcely as it really hurts the exploration part of
the algorithm.
* **Parallelization**: MoGo and the likes can become very good on
  computer clusters, since the random game part can be run on mutliple
CPUs. The [speedup factor](http://en.wikipedia.org/wiki/Amdahl's_law) is
about 8x.
* **Reinforcement learning**: MoGo learns during the game and the
  randoms play-outs that some combinations are likely to have a bad
result, and assigns them a lower probability.  

You can learn more on MoGo [in this article](http://www.pleinsud.u-psud.fr/specialR2008/en/12_GOthique.pdf).  


## Strength of computers
Today, Go-playing programs are able to compete with professional players on small (9x9) boards, but are still very weak on normal-sized boards (19x19). There is still a long way to go!  



*I am a Go player myself, even though not very good! During an
internship in a Computer Science laboratory, I worked on [MoGo](http://www.lri.fr/~teytaud/mogo.html) for 2 months in 2008.*
